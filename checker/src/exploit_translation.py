import string
from collections import defaultdict
import re
from Crypto.Cipher import ChaCha20
from typing import ByteString, List

PER_LETTER = 4096 // 26

def create_word_arr(text: str) -> List[str]:
    words = [w.strip() for w in text.splitlines() if w.strip()]

    groups: dict[str, List[str]] = defaultdict(list)
    for w in words:
        ch = w[0].lower()
        if ch in string.ascii_lowercase:
            groups[ch].append(w)

    arr: List[str] = []
    used: set[str] = set()

    for letter in string.ascii_lowercase:
        bucket = groups.get(letter, [])
        if not bucket:
            continue 

        count = 0
        for w in bucket:
            if w not in used:
                arr.append(w)
                used.add(w)
                count += 1
                if count == PER_LETTER:
                    break

    for w in words:
        if len(arr) == 4096:
            break
        if w not in used:
            arr.append(w)
            used.add(w)

    if len(arr) != 4096:
        raise ValueError(f"Only {len(arr)} unique words available—need 4096")

    return arr

def extract_vtt_words(vtt_text: str) -> list[str]:
    words = []

    timestamp_re = re.compile(r'^\d{2}:\d{2}:\d{2}\.\d{3}\s+-->\s+\d{2}:\d{2}:\d{2}\.\d{3}$')
    
    for line in vtt_text.splitlines():
        line = line.strip()

        if not line or line.isdigit() or timestamp_re.match(line) or line == "WEBVTT":
            continue
        words.extend(line.split())
    
    return words

def create_inverse_dict(word_list:list) -> dict:
    dict = {}
    for i, word in enumerate(word_list):
        dict[word] = i
    return dict

def get_indices(words: list[str]) ->list[int]:
    for word in words:
        if word not in dicti:
            raise ValueError(f"Word '{word}' not found in dictionary")
    return [dicti[word] for word in words]



def unpack_indices(indices: list[int]) -> bytes:

    bits = 0
    bitcount = 0
    out = []

    for idx in indices:
        bits = (bits << 12) | idx
        bitcount += 12
        while bitcount >= 8:
            bitcount -= 8
            out.append((bits >> bitcount) & 0xFF)

    pad = bitcount  

    total_bits = len(indices) * 12
    orig_len   = (total_bits - pad) // 8
    
    if out[-1] == 0:
        out.pop()
    
    
    print(f"Total bits: {total_bits}, Pad size: {pad}, Original length: {orig_len}")
    print(f"total % 12: {total_bits % 12}, pad % 8: {total_bits % 8}")

    return bytes(out[:orig_len])



class ChaCha20Rng:
    def __init__(self, duration: float):
        ms = int(round(duration * 1000))
        if ms == 0:
            ms = 1
        key = ms.to_bytes(8, 'little') + b'\x00'*24
        self.cipher = ChaCha20.new(key=key, nonce=b'\x00'*8)

    def next_u64(self) -> int:
        block = self.cipher.encrypt(b'\x00'*8)
        return int.from_bytes(block, 'little')

def get_blob(blob: ByteString, duration: float) -> bytes:
    rng = ChaCha20Rng(duration)
    out = bytearray(len(blob))
    for i, b in enumerate(blob):
        full = rng.next_u64()
        byte = full & 0xFF
        print(f"Full: {full:#018x}, keystream byte: {byte:#04x}")
        print(f"Byte {i}: {b:#04x} ^ {byte:#04x} = {b ^ byte:#04x}")
        out[i] = b ^ byte
    return bytes(out)


duration = 4.40
vtt_content = """WEBVTT

1
00:00:00.000 --> 00:00:00.880
oblicuidad macabra

2
00:00:00.880 --> 00:00:01.760
yerbera habilosa

3
00:00:01.760 --> 00:00:02.640
damasquino lacerto

4
00:00:02.640 --> 00:00:03.520
xerófilo nabatea
"""

bf= """
WEBVTT

1
00:00:00.000 --> 00:00:00.880
rabatí habilitada yerta dadivada echadora abetunado zabordamiento

2
00:00:00.880 --> 00:00:01.760
hacienda zaguera aballar tabulador sabela iberorrománico tabo

3
00:00:01.760 --> 00:00:02.640
aborregada machalera obispo abacalera labradera bacinilla xenogénico

4
00:00:02.640 --> 00:00:03.520
náhuatl xocoyote kopek habilindroso nafta abanderado pachá

5
00:00:03.520 --> 00:00:04.400
yacuibeño abigotado obsecuencia macana caballerete rabiosamente lacayuna

"""

cont2="""
WEBVTT

1
00:00:00.000 --> 00:00:00.880
sabicú facetada ultraísta zalbo abacalera nadgada

2
00:00:00.880 --> 00:00:01.760
abonar zahén xerófita abaleo xérica badajear

3
00:00:01.760 --> 00:00:02.640
i gachonada yámbica baccarat ucrónico pachuco

4
00:00:02.640 --> 00:00:03.520
fachento lacho xerografiar pachón quelital abogadesco

5
00:00:03.520 --> 00:00:04.400
macabea sabandija




"""
orig = "hallo alter"

#ENO908dqwhiouisafldbj8329prhudfewsbfiulsdlfjibkasnuiph3289eprhwsfpuihAAABBB
#ENO098wqe796ewr
#ENO987623adsasd
#ENO980217234sadfgfdx
#CrazyToThinkThatAFlagContains<<>>BrainfuckChars>>!!!

#ENOHAHAHAH91032984732842834hoffeesklappt<<>>....!![][]qweqac

cont3="""
WEBVTT

1
00:00:00.000 --> 00:00:00.880
sabicú facetada ultraísta zalbo abacalera nadgada

2
00:00:00.880 --> 00:00:01.760
abonar zahén xerófita abaleo xérica badajear

3
00:00:01.760 --> 00:00:02.640
i gachonada yámbica baccarat ucrónico pachuco

4
00:00:02.640 --> 00:00:03.520
fachento lacho xerografiar pachón quelital abogadesco

5
00:00:03.520 --> 00:00:04.400
macabea sabandija ideosa wau tabor jadeo



"""

cont4 = """
WEBVTT

1
00:00:00.000 --> 00:00:00.880
querencioso vagar saboreo abastecer labradoril

2
00:00:00.880 --> 00:00:01.760
abarrotería valaco habituación Pablo facial

3
00:00:01.760 --> 00:00:02.640
zajón hábilmente abayado hachemí pacotillera

4
00:00:02.640 --> 00:00:03.520
gafe washingtoniano queratosis gacheta obsesivo-compulsiva

5
00:00:03.520 --> 00:00:04.400
xenogénico querellada sableada gago



"""

#@++++++++[>++++[>++>+++>+++>+<<<<-@
if __name__ == "__main__":
    with open("spanish_words.txt", encoding="utf-8") as f:
        raw = f.read()
    codebook = create_word_arr(raw)
    
    words = extract_vtt_words(cont4)
    dicti = create_inverse_dict(codebook)
    indices = get_indices(words)
    print(indices)
    print(unpack_indices(indices))
    s = get_blob(unpack_indices(indices), duration)
    print(s)
    for byte in s:
        print(chr(byte), end="")

    if '@++++++++[>++++[>++>+++>+++>+<<<<-@' == s.decode('utf-8'):
        print("\nExploit successful!")