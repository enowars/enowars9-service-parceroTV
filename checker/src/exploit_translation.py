import string
from collections import defaultdict
import re
from Crypto.Cipher import ChaCha20
from typing import ByteString, List



PER_LETTER = 4096 // 26

def create_word_arr(text: str) -> List[str]:
    words = [w.strip() for w in text.splitlines() if w.strip()]
    groups: dict[str, List[str]] = defaultdict(list)
    for w in words:
        ch = w[0].lower()
        if ch in string.ascii_lowercase:
            groups[ch].append(w)

    arr: List[str] = []
    used: set[str] = set()

    for letter in string.ascii_lowercase:
        bucket = groups.get(letter, [])
        if not bucket:
            continue 

        count = 0
        for w in bucket:
            if w not in used:
                arr.append(w)
                used.add(w)
                count += 1
                if count == PER_LETTER:
                    break

    for w in words:
        if len(arr) == 4096:
            break
        if w not in used:
            arr.append(w)
            used.add(w)

    if len(arr) != 4096:
        raise ValueError(f"Only {len(arr)} unique words availableâ€”need 4096")
    
    print(arr)
    
    return arr

def extract_vtt_words(vtt_text: str) -> list[str]:
    words = []

    timestamp_re = re.compile(r'^\d{2}:\d{2}:\d{2}\.\d{3}\s+-->\s+\d{2}:\d{2}:\d{2}\.\d{3}$')
    
    for line in vtt_text.splitlines():
        line = line.strip()

        if not line or line.isdigit() or timestamp_re.match(line) or line == "WEBVTT":
            continue
        words.extend(line.split())
    
    return words

def create_inverse_dict(word_list:list) -> dict:
    dict = {}
    for i, word in enumerate(word_list):
        dict[word] = i
    return dict

def get_indices(words: list[str], dicti: dict) ->list[int]:
    for word in words:
        if word not in dicti:
            raise ValueError(f"Word '{word}' not found in dictionary")
    return [dicti[word] for word in words]



def unpack_indices(indices: list[int]) -> bytes:

    bits = 0
    bitcount = 0
    out = []

    for idx in indices:
        bits = (bits << 12) | idx
        bitcount += 12
        while bitcount >= 8:
            bitcount -= 8
            out.append((bits >> bitcount) & 0xFF)

    pad = bitcount  

    total_bits = len(indices) * 12
    orig_len   = (total_bits - pad) // 8
    
    if out[-1] == 0:
        out.pop()
    
    
    print(f"Total bits: {total_bits}, Pad size: {pad}, Original length: {orig_len}")
    print(f"total % 12: {total_bits % 12}, pad % 8: {total_bits % 8}")

    return bytes(out[:orig_len])



class ChaCha20Rng:
    def __init__(self, duration: float):
        ms = int(round(duration * 1000))
        if ms == 0:
            ms = 1
        key = ms.to_bytes(8, 'little') + b'\x00'*24
        self.cipher = ChaCha20.new(key=key, nonce=b'\x00'*8)

    def next_u64(self) -> int:
        block = self.cipher.encrypt(b'\x00'*8)
        return int.from_bytes(block, 'little')

def get_blob(blob: ByteString, duration: float) -> bytes:
    rng = ChaCha20Rng(duration)
    out = bytearray(len(blob))
    for i, b in enumerate(blob):
        full = rng.next_u64()
        byte = full & 0xFF
        print(f"Full: {full:#018x}, keystream byte: {byte:#04x}")
        print(f"Byte {i}: {b:#04x} ^ {byte:#04x} = {b ^ byte:#04x}")
        out[i] = b ^ byte
    return bytes(out)


def full_exploit_for_shorts(duration: float, vtt) -> str:
    with open("spanish_words.txt", encoding="utf-8") as f:
        raw = f.read()
    codebook = create_word_arr(raw)

    words = extract_vtt_words(vtt)
    dictionary = create_inverse_dict(codebook)
    indices = get_indices(words, dictionary)
    s = get_blob(unpack_indices(indices), duration)
    return s.decode('utf-8')


if __name__ == "__main__":
    #Use full_exploit_for_shorts to get the flag
    pass